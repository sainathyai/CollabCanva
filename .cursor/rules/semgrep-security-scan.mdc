---
description: Mandatory security scanning of all generated code using Semgrep MCP server
globs: **/*.{js,jsx,ts,tsx,py,java,go,rb,php,c,cpp,cs,swift,kt}
---

# Rule: Semgrep MCP Security Scan

// Description: Mandatory security scanning of all generated code using Semgrep MCP server
// Globs: **/*.{js,jsx,ts,tsx,py,java,go,rb,php,c,cpp,cs,swift,kt}

## Purpose

This rule ensures that ALL code generated by the AI is automatically scanned for security vulnerabilities using the Semgrep MCP server before being considered complete.

## Mandatory Requirement

**ALWAYS scan code generated using Semgrep for security vulnerabilities.**

This is not optional. Every code generation task must include a security scan step.

## When to Scan

Security scans MUST be performed:
1. After generating any new code files
2. After modifying existing code files
3. Before marking a task as complete
4. Before committing code changes
5. When explicitly requested by the user

## Scan Workflow

1. **Generate Code**: Complete the requested code generation or modification
2. **Run Security Scan**: Use Semgrep MCP to scan the generated code
3. **Review Results**: Analyze any security findings
4. **Fix Issues**: Address any security vulnerabilities found
5. **Re-scan if Needed**: Verify fixes with another scan
6. **Confirm Clean**: Only proceed when no security issues remain

## Using Semgrep MCP

The Semgrep MCP server provides several tools for security scanning:

### Available MCP Tools
- `mcp_semgrep_security_check`: Fast security check for code
- `mcp_semgrep_semgrep_scan`: Full Semgrep scan with custom configs
- `mcp_semgrep_semgrep_scan_local`: Scan local files by absolute path
- `mcp_semgrep_semgrep_findings`: Query existing findings from Semgrep AppSec Platform

### Recommended Approach

Use `mcp_semgrep_security_check` for quick validation:
```
mcp_semgrep_security_check({
  code_files: [
    { filename: 'app.js', content: '...' }
  ]
})
```

## Handling Findings

When security issues are discovered:

1. **Report Findings**: Clearly communicate what was found
2. **Explain Impact**: Describe the security implications
3. **Propose Fixes**: Suggest specific remediation steps
4. **Implement Fixes**: Apply the security fixes to the code
5. **Verify**: Re-scan to confirm the issues are resolved

## Best Practices

- **Scan Early**: Run security checks as soon as code is generated
- **Be Proactive**: Don't wait for the user to request a scan
- **Fix Immediately**: Address security issues before moving forward
- **Document**: Note what was scanned and the results
- **Educate**: Explain why certain patterns are insecure

## Example Workflow

```
1. User requests: "Create an authentication endpoint"
2. AI generates the code
3. AI immediately runs security scan
4. If issues found:
   - Report: "Found SQL injection vulnerability"
   - Fix: Update code with parameterized queries
   - Re-scan: Verify the fix
5. Confirm: "Code generated and security verified âœ“"
```

## Security Scan Checklist

Before completing any code generation task:

- [ ] Code has been generated/modified
- [ ] Security scan has been run
- [ ] Results have been reviewed
- [ ] Any findings have been addressed
- [ ] Re-scan confirms no issues remain
- [ ] User has been informed of security status

## Non-Compliance

Code should NOT be delivered without a security scan. If scanning fails or is unavailable:

1. Inform the user immediately
2. Explain the security risk of unscanned code
3. Recommend manual security review
4. Document the gap in security verification

## Integration with Development Flow

This rule integrates with other development rules:
- Run BEFORE commit message generation
- Run AFTER process task list completion
- Run DURING feature development
- Run BEFORE deployment preparation

## Remember

**Security is not optional. Every line of code generated must be scanned for vulnerabilities.**